[
{
	"uri": "/vi/",
	"title": "AWS Serverless SaaS Workshop",
	"tags": [],
	"description": "",
	"content": "AWS Serverless SaaS Workshop Tổng quan Trong bài workshop này, chúng ta sẽ xây dựng một solution Software-as-a-Service (SaaS) sử dụng các services serverless của AWS như Amazon API Gateway, Amazon Cognito, AWS Lambda, Amazon DynamoDB và Amazon CloudWatch. Mục tiêu của chúng ta là đưa đến cho các developers, architectures của SaaS đang làm việc với code có thể hiểu được cách thiết kế và chuyển sang sử dụng solution SaaS trên AWS.\nBài workshop này được viết dựa vào SaaS Factory Serverless SaaS reference solution. Ở cuối buổi workshop này, bạn sẽ xây dược được ứng dụng SaaS với đầy đủ các chức năng của reference solution ở trên. Điều đáng chú ý trong buổi workshop này là các bạn không cần thiết phải hiểu reference solution trước đó. Bạn chỉ cần làm theo hướng dẫn, từng bước một và đọc kĩ những lời giải thích thì sẽ dễ hiểu và nắm được reference solution này.\nHình dưới đây là sơ đồ cấu trúc của reference solution trên.\nNội dung Giới thiệu Các bước chuẩn bị Xây dựng một serverless backend với AWS Lambda và AWS SAM Cấu hình cho API authorization: API Gateway Build và deploy ứng dụng web: AWS Amplify Chạy thử ứng dụng Cấu hình cho trính xuất metadata từ hình ảnh: Amazon Rekognition Dọn dẹp tài nguyên "
},
{
	"uri": "/vi/1-introduce/1.1-whatsaas/",
	"title": "Delivery model SaaS có gì độc đáo?",
	"tags": [],
	"description": "",
	"content": "Software-as-a-Service (SaaS) là một delivery model của software và business cho phép các tổ chức cung cấp các giải pháp của họ theo low-friction và service-centric approach. Mô hình SaaS dựa trên sự linh hoạt và hiệu quả hoạt động như là trụ cột của các chiến lượt kinh doanh nhằm thúc đẩy tăng trưởng, phạm vi tiếp cận và đổi mới.\nMặc dù có nhiều thách thức trong công cuộc kinh doanh cần được giải quyết nhưng có một vài đặc điểm của kiến trúc, nó là cần thiết cho sự thành công của delivery model dựa trên SaaS. Dưới đây là những thách thức cơ bản mà chúng ta sẽ gặp phải khi xây dựng cấu trúc của solution dựa trên SaaS. Mục tiêu của chúng ta ở đây là giải quyết những thách thức này khi chúng ta đi vào thực hiện buổi workshop này.\nAgility Trong khi xây dựng kiến trúc cho solution của chúng ta, chúng ta nên chọn các công nghệ giúp chúng ta triển khai nhanh hơn, đáp ứng nhanh hơn với các yêu cầu từ khách hàng và thị trường. Trong buổi workshop này, chúng ta sẽ cách các service serverless giúp chúng ta triển khai nhanh hơn và loại bỏ những gánh nặng trong việc quản lí hạ tầng.\nAutomated Onboarding Một trong những thách thức lớn nhất trong việc xây dựng một solution dựa trên SaaS là việc onboarding khách hàng. Chúng ta cần phải có một quy trình onboarding tự động để giảm thiểu sự can thiệp của con người trong quá trình onboarding. Trong buổi workshop này, chúng ta sẽ sử dụng các công cụ của AWS để tự động hóa quá trình onboarding.\nIdentity managment Buổi workshop này sẽ cho chúng ta biết cách mà tenants và users của chúng ta có thể tương tác với hệ thống một cách an toàn, bảo mật. Chúng ta sẽ đạt được mục đích này khi xây dựng một hệ thống cho identity management lể lưu trữ và xác thực người dùng theo tenant-aware fashion.\n"
},
{
	"uri": "/vi/5-deploy/5.1-deployserverless/",
	"title": "Deploy Serverless Application",
	"tags": [],
	"description": "",
	"content": "Trong bước này, chúng ta sẽ sử dụng SAM CLI để build và deploy ứng dụng serverless.\nĐầu tiên, chúng ta cần chắc chắn rằng đã cập nhật phiên bản mới nhất của SAM CLI.\npip install --user --upgrade aws-sam-cli Chúng ta sẽ thấy output như hình. Tiếp theo, đi đến thư mục sam:\ncd ~/environment/serverless-tasks-webapp/sam Chạy câu lệnh dưới đây để build ứng dụng:\nsam build Khi build thành công, chúng ta sẽ có như hình.\nCâu lệnh sam build xử lí file template AWS SAM, code của ứng dụng và những dependencies. Nó cũng coppy build artifacts theo một format và ví trị được xác định sẵn trong workflow của bạn.\nBây giờ, chúng ta sẽ deploy ứng dụng:\nsam deploy --guided Câu lệnh này sẽ đóng gói và deploy ứng dụng lên account AWS của chúng ta.\nĐầu tiên, nó sẽ hỏi chúng ta tên stack, chúng ta có thể đặt tên bất kỳ, ở đây chúng ta đặt là tasks-app. Sau đó sẽ chọn region mà chúng ta muốn deploy ứng dụng lên, ở đây chúng ta chọn ap-southeast-1.\nTiếp theo, chúng ta sẽ nhập y và nhấn Enter để confirm deploy.\nĐể cho phép SAM có thể tạo roles để kết nối tới các resources trong template của chúng ta, hãy cho phép SAM CLI tạo ra IAM roles, chúng ta nhập Y và nhấn Enter.\nVô hiệu hóa rollback để bảo vệ những resources của chúng ta khi quá trình khiển khai thất bại, chúng ta nhập y và nhấn Enter.\nCho phép lưu các arguments vào file cấu hình, chúng ta nhập Y và nhấn Enter.\nVì file SAM configuration chưa có nên chúng ta tạo ra nó, chúng ta nhấn Enter để mặc định, tương tự với môi trường của SAM configuration.\nKiểm tra lại thông tin trước khi deploy.\nNếu deploy thành công, chúng ta sẽ thấy output như hình.\nHãy ghi chú và lưu lại giá trị của key TasksApi và S3BucketName, nó sẽ cần cho những bước tiếp theo.\n"
},
{
	"uri": "/vi/3-serverless/3.1-deploy/",
	"title": "Deploy ứng dụng",
	"tags": [],
	"description": "",
	"content": "\rỞ bước trước, bạn đã được cung cấp tài liệu để tìm hiểu cấu trúc và cách deploy ứng dụng serverless với SAM template tại đây. Trong bài này chúng ta sẽ bỏ qua chi tiết những bước đó và chỉ cần chạy file script.\nChúng ta cùng deploy ứng dụng serverless bằng cách chạy câu lẹnh dưới đây trong terminal của Cloud9.\ncd ~/environment/aws-serverless-saas-workshop/Lab1/scripts/\r./deployment.sh -s -c --stack-name serverless-saas-workshop-lab1 Chúng ta sẽ đợi khoảng từ 5 đến 8 phút để script chạy hoàn thành. Ở trong câu lệnh ở trên, các parameters -c và -s ở đây biểu thị rằng chúng ta đang deploy cả code của server và client side. Sau khi chạy script hoàn thành, nó sẽ hiển thị URL của ứng dụng như hình.\n"
},
{
	"uri": "/vi/1-introduce/",
	"title": "Giới thiệu",
	"tags": [],
	"description": "",
	"content": "Trước khi chúng ta đi sâu vào những dòng code, điều đầu tiên chúng ta cần làm là hãy hiểu về cấu trúc được tạo ra trong lúc xây dựng một solution SaaS-based. Trong phần này sẽ đưa chúng ta đến với những ý tưởng để sau này thực hiện những thiết kế mà chúng ta tự làm và có thể hiểu được rõ hơn những gì chúng ta xây dựng trong buổi workshop này. Chúng ta sẽ cùng tìm hiểu tại sao serverless lại phù hợp để sử dụng trong mô hình này và những service serverless nào được sử dụng trong suốt buổi workshop.\n"
},
{
	"uri": "/vi/6-test/6.1-dynamodb/",
	"title": "Quản lí dữ liệu trong DynamoDB",
	"tags": [],
	"description": "",
	"content": " Nhập DynamoDB ở thanh tìm kiếm service trên AWS Console sau đó chọn DynamoDB. Ở thanh điều hướng bên trái, chọn Tables. Click vào table có tên bao gồm tên của ứng của chúng ta tasks-app-TasksTable. Đây là table được tạo bởi SAM template. Click vào nút Explore table items. Chúng ta sẽ thấy dữ liệu ở trong table ở phần Items returned.\nClick vào partition key (user) của bảng đó sẽ đưa bạn đến nơi chỉnh sửa thông tin của item đó.\nKhi bạn thay đổi dữ liệu ở DynamoDB, chúng ta cần refresh lại trang web của ứng dụng để thấy được sự thay đổi.\n"
},
{
	"uri": "/vi/2-prerequiste/2.1-createcloud9workspace/",
	"title": "Tạo Cloud9 Workspace",
	"tags": [],
	"description": "",
	"content": "Khởi tạo Cloud9 Nhập Cloud9 ở thanh tìm kiếm service trên AWS Console sau đó chọn Cloud9. Chọn Create environment Đặt tên cho Cloud9 Workspace là saas-workshop. Ở mục Description hãy nhập mục đích bạn muốn sử dụng trong workspace này. Nhập Saas workshop with serverless Environment type, ở đây chúng ta sẽ tạo một server để chạy Cloud9 workspace này. Mình sẽ chọn option New EC2 instance để tạo một server mới. Sang phần setting cho New EC2 instance, chọn Additional instance types sau đó chúng ta chọn loại t3.large. Giữ nguyên mặc định cho những thiết lập khác. Click nút Create. Đợi khoảng 10 phút để Cloud9 Workspace được tạo. Khi Cloud9 Workspace được tạo xong, chúng ta sẽ có một môi trường để làm việc với AWS CLI và các công cụ khác. Trong danh sách các Environments được tạo ra, hãy tìm environment serverless-workshop và click vào nút Open để mở môi trường Cloud9. Sau khi môi trường mở ra, chúng ta hãy tắt những phần bên dưới đã được khởi tạo lúc bắt đầu và tạo một trang terminal mới. Hãy chắc chắn rằng bạn đã tắt tất cả các tab đã tổn tại khi chúng ta mở Cloud9 IDE trước khi chúng ta thực hiện một hoạt đồng nào đó, hãy click vào X button để tắt tab đó. Cái này rất cần thiết để đảm bảo rằng bước tiếp theo khi cài đặt những công cụ cần thiết cho workshop này sẽ không bị ảnh hưởng.\nWorkspace của chúng ta sẽ trông như thế này.\n"
},
{
	"uri": "/vi/2-prerequiste/",
	"title": "Các bước chuẩn bị",
	"tags": [],
	"description": "",
	"content": "API Gateway - REST API Ở bước này, bạn có thể sử dụng Amazon API Gateway console để create và test một simple REST API với tích hợp HTTP cho website của bạn.\nVí dụ với website PeetStore, API sẽ hỗ trợ các phương thức cho client truy cập vào phía backend của website http://petstore-demo-endpoint.execute-api.com/petstore/pets.\nGET / : cho phép truy cập và đọc dữ liệu từ resource gốc của API. API Gateway sẽ phản hồi với một dữ liệu có sẵn trong cửa hàng. GET /pests : cho phép truy cập và đọc dữ liệu từ resource của API /pets được tích hợp với tên phụ trợ /pets. Backend trả về cho page những pets có sẵn trong store. Đây là ví dụ khi tích hợp với HTTP, URL có tên như này http://petstore-demo-endpoint.execute-api.com/petstore/pets. POST /pets : cho phép truy cập và thêm dữ liệu vào resource của API /pets được tích hợp với tên phụ trợ /petstore/pets. Khi nhận được yêu cầu chính xác, backend sẽ thêm pets chính xác vào PetStore và trả kết quả về với caller. Nó cũng được tích hợp vs HTTP. API hỗ trợ truy cập CORS thông qua các phương thức tùy chọn của loại tích hợp có tên là MOCK. API Gateways trả về các headers hỗ trợ truy cập CORS. Chúng tôi sẽ hướng dẫn bạn các bước để tạo và kiểm tra API từ ví dụ ở trên sử dụng API Gateway Console.\nCloud9 Workspace Bạn có thể deploy ứng dụng của bạn từ môi trường làm việc local nếu bạn muốn nhưng tôi khuyến khích bạn sử dụng AWS Cloud9 integrated development environment (IDE).\nHãy nhớ rằng Cloud9 workspace chỉ nên được tạo ra bởi IAM user (hoặc là được gán vào một IAM role thích hợp) với đặc quyền của Admin, không được dùng root user.\nChúng ta thường dùng môi trường phát triển tích hợp (Integrated Development Environment - IDE) ở local, trong bài workshop này, chúng ta sẽ dùng Cloud9. Nó là một IDE chạy trên cloud sử dụng trình duyệt, bao gồm những tính năng quan trọng, thiết yếu ở local IDE mà chúng ta thường dùng như viết, chạy, debug code. Cloud9 đã được trang bị sẵn những gói tệp tin như JavaScript, Python, NodeJS và những thứ khác ở đây\nĐể các dịch vụ của AWS phản hồi nhanh hơn, hãy chọn Region gần nhất trong suốt buổi workshop.\nNội dung Tạo Cloud9 Workspace Cài đặt Amplify CLI "
},
{
	"uri": "/vi/5-deploy/5.2-configapigateway/",
	"title": "Cấu hình API Gateway endpoint",
	"tags": [],
	"description": "",
	"content": "Sau khi chạy câu lệnh sam deploy --guided ở bước trước đó, bạn sẽ nhận được URL của API Gateway endpoint.\nỨng dụng web yêu cầu cấu hình cho endpoint này để nó có thể biết được nơi để gửi các request.\nCoppy URL của API Gateway endpoint của ứng dụng chúng ta, vào thư mục /webapp/src, mở file main.js. Paste URL đó vào giá trị của axios.defaults.baseURL như hình.\nHãy lưu ý rằng bạn đã coppy bao gồm tên của stage /v1 trong URL đó và xóa đi dấu / ở cuối URL.\nDòng Vue.config.productionTip = false sẽ tắt các tip được hiển thị trong Vue console, nó sẽ tối ưu hóa trong môi trường production.\nTiếp theo, chúng ta sẽ set mặc định URL cho tất cả Axios requests. Nó sẽ là endpoint URL nơi mà API request được gửi đến.\nTổng quát, đoạn code phía trên khởi tạo ứng dụng Vue.js bằng cách tạo một Vue instance, cấu hình base URL cho Axios requests. Nó cũng tắt các tip được hiển thị trong Vue console.\n"
},
{
	"uri": "/vi/6-test/6.2-logandmonitor/",
	"title": "Logging và Monitoring",
	"tags": [],
	"description": "",
	"content": "Logging Centralized logging cho chúng ta 2 lợi ích quan trọng. Đầu tiên các log được ghi lại được lưu trữ trong một nơi duy nhất và được format theo một tiêu chuẩn nhất định, giúp chúng ta đơn giản trong việc quản lí các tasks và phân tích logs. Thứ hai, nó cung cấp cho chúng ta một nơi lưu trữ an toàn cho dữ liệu của các logs của chúng ta.\nTrong AWS Lambda, service logging mặc định là Amazon CloudWatch.\nLambda tự động truyền thông tin về các lúc gọi function, cùng với các logs và output từ code của functions của chúng ta sang CloudWatch Logs.\nCác nhóm log là một phần tiêu chuẩn của CloudWatch và được dùng để phân loại các logs. Bất kì các logs được tạo bởi Lambda function đều có quy ước đặt tên là /aws/lambda/function-name. Một nhóm log là một tập hợp các log streams, bạn có thể xem chi tiết nó trong CloudWatch console.\nNhập CloudWatch ở thanh tìm kiếm service trên AWS Console sau đó chọn CloudWatch. Ở thanh điều hướng bên trái, chọn Log groups. Chọn log group với function CreateTaskFunction. Mỗi phiên bản của một Lambda function có một stream log riêng. Nếu một function được mở rộng thì phiên bản mới đó đồng thời có log stream riêng. Mỗi khi một environment được chọn để thực thi và một environment mới được tạo ra để đáp ứng một lượng invocation nhất định và nó sẽ tạo ra một log stream mới. Cách đặt tên cho các log streams là YYYY/MM//DD [Function version] [Execution environment GUID]\nVí dụ, đây là log stream của function CreateTaskFunction.\nTrong những logs trên này có:\nRequestId: là một ID duy nhất được tạo ra cho mỗi lần gọi function. Nếu Lambda function gọi lại request thì ID này sẽ không thay đổi và giữ nguyên trong logs cho mỗi lần gọi lại tiếp theo. Start/End: các giá trị này đánh dấu một invocation, vì vậy những dòng log ở giữa các giá trị này đều thuộc về chung một invocation. Duration: thời gian thực thi của function. Billed Duration: phép toán làm tròn cho Duration. Memory Size: kích thước bộ nhớ được cấp phát cho function. Max Memory Used: kích thước bộ nhớ tối đa được sử dụng trong quá trình thực thi function. Init Duration: thời gian tính từ khi chạy phần INIT. Monitoring Metrics là dữ liệu số đo ở các khoảng thời gian khác nhau (time series data) và chỉ số service-level (request rate, error rate, duration, CPU, etc). Lambda tự động publish một lượng metrics cho Lambda functions.\nĐể theo dõi và quan sát các Lambda functions, các metrics quan trọng nhất là:\nErrors: Liệu rằng errors có phải do logic hoặc do runtime trong code hoặc do tương tác lỗi với Lambda service hoặc các services khác gây ra hay không. Những thứ này đều có thể do các yếu tố khác gây ra, chẳng hạn như là không được cấp quyền hoặc vượt quá resource limit. Excution time: Đo thời gian response chỉ cho chúng ta cái nhìn hạn chế về hiệu suất trong distributed applications. Điều quan trọng là nắm bắt và theo dõi hiệu suất ở các khoảng phần trăm (chẳng hạn như 95% và 99%) để đo lường hiệu suất cho ít nhất 5% và 1% requests. Throttling: Ứng dụng serverless sử dụng resource có thể mở rộng với Service Quotas để bảo đảm cho khách hàng. Throttling có thể cho chúng ta biết quotas được thiết lập không chính xác, có lỗi trong cấu trúc của hệ thống hoặc mức lưu lượng truy cập vượt quá giới hạn. Tất cả Lambda functions tự động tích hợp với CloudWatch. Lambda tự động ghi lại nhiều metrics, nó luôn được publish lên CloudWatch metrics. Nếu bạn điều huwosng đến một function trong Lambda, phần Monitor của mục Metrics cho chúng ta xem nhanh về các CloudWatch metrics được tích hợp với một function.\nĐể có thể vào xem Mornitor, hãy vào Lambda console, chọn Lambda function mà bạn muốn xem. Vào thẻ Monitor, ở phần Metrics, chúng ta có thể xem các metrics của function. Xem minh họa ở hình bên dưới.\nTiếp theo, chúng ta sẽ thêm tính năng mới vào ứng dụng web của chúng ta với Amazon Rekognition.\n"
},
{
	"uri": "/vi/1-introduce/1.2-whyserverless/",
	"title": "Tại sao sử dụng Serverless?",
	"tags": [],
	"description": "",
	"content": "AWS Serverless Servoces cho phép bạn tập trung vào SaaS solution mà không cần phải quản lí servers. Nó giải quyết những vấn đề, thách thức trong việc xây dựng delivery model dựa trên SaaS.\nNhà cung cấp SaaS có thể tiếp cận thị trường nhanh hơn vì Serverless giúp chúng ta loại bỏ đi việc vận hành. Bạn chỉ trả phí cho những gì bạn sử dụng và nó giúp cho các nhà cung cấp SaaS bỏ qua giai đoạn đầu tư ban đầu của tenants/customers. Serverless cho phép bạn mở rộng quy mô theo dung lượng của người dùng. Điều này cực kì quan trọng, vì ban đầu bạn sẽ không thể xác định được dung lượng mà tenants sẽ cần trên hệ thống của bạn. Cuối cùng, các nhà cung cấp SaaS có thể tập trung vào IP của họ thay vì phải suy nghĩ về việc mở rộng quy mô và quản lí cơ sở hạ tầng. "
},
{
	"uri": "/vi/3-serverless/3.2-lambdafunction/",
	"title": "Tạo Lambda function",
	"tags": [],
	"description": "",
	"content": "AWS Lambda là gì? AWS Lambda là một dịch vụ serverless nó sẽ thực thi những dòng code mà không cần phải chuẩn bị và quản lí servers. Lambda tự động phân bổ dung lượng máy tính và chạy code của bạn dựa vào những yêu cầu hoặc sự kiện được gửi đến trong tất cả các môi trường, các điều kiện.\nCách nó hoạt động:\nTải code của bạn lên AWS Lambda hoặc viết code trên trình chỉnh sửa của Lambda. (Trong workshop này, chúng ta sẽ viết code và tải lên bằng SAM) Cài đặt code của bạn cho phép trigger từ những AWS services khác, từ HTTP endpoints, hay là những hoạt động xảy ra bên trong ứng dụng. AWS Lambda sẽ thực thi code của bạn khi trigger được kích hoạt, sau đó nó sẽ tự động quản lí tài nguyên tính toán cho code của bạn. Chỉ trả tiền cho thời gian thực thi code của bạn (và số lượng tài nguyên tính toán mà code của bạn sử dụng). Phân tích một Lambda function Lambda function handler là một hàm trong code của bạn, nó sẽ xử lí các events. Khi một chức năng được gọi, Lambda sẽ thực thi hàm handler. Khi hàm handler kết thúc và return response, nó sẽ sẵn sàng thực hiện những events khác.\nVí dụ về cấu trúc của Lambda function:\nexports.handler = async (event) =\u0026gt; {\r// TODO implement\rconst response = {\rstatusCode: 200,\rbody: JSON.stringify(\u0026#39;Hello from Lambda!\u0026#39;),\r};\rreturn response;\r}; Ở đây, event là request được gửi đến và response là kết quả trả về.\nTạo Lambda function Truy cập đến đường dẫn sam/src/handlers/createTask và chọn file tên là app.js, coppy và paste đoạn code sau vào file:\nconst { DynamoDBClient } = require(\u0026#39;@aws-sdk/client-dynamodb\u0026#39;)\rconst { DynamoDBDocumentClient, PutCommand } = require(\u0026#39;@aws-sdk/lib-dynamodb\u0026#39;)\rconst uuid = require(\u0026#39;uuid\u0026#39;)\rconst ddbClient = new DynamoDBClient()\rconst ddbDocClient = DynamoDBDocumentClient.from(ddbClient)\rconst tableName = process.env.TASKS_TABLE\rexports.handler = async (event) =\u0026gt; {\rconsole.info(\u0026#39;received:\u0026#39;, event)\rconst body = JSON.parse(event.body)\rconst user = event.requestContext.authorizer.principalId\rconst id = uuid.v4()\rconst title = body.title\rconst bodyText = body.body\rconst createdAt = new Date().toISOString()\rlet dueDate = createdAt\rif (\u0026#39;dueDate\u0026#39; in body) {\rdueDate = body.dueDate\r}\rconst params = {\rTableName: tableName,\rItem: { user: `user#${user}`, id: `task#${id}`, title: title, body: bodyText, dueDate: dueDate, createdAt: createdAt }\r}\rconsole.info(`Writing data to table ${tableName}`)\rconst data = await ddbDocClient.send(new PutCommand(params))\rconsole.log(\u0026#39;Success - item added or updated\u0026#39;, data)\rconst response = {\rstatusCode: 200,\rheaders: {\r\u0026#39;Access-Control-Allow-Origin\u0026#39;: \u0026#39;*\u0026#39;\r},\rbody: JSON.stringify(data)\r}\rreturn response\r} Đoạn code này đã import thư viện AWS SDK cho DynamoDB, thư viện uuid cho việc nhận dạng, cài đặt DynamoDB client.\nLambda function được khởi tạo với exports.handler, nó đóng vai trò như một entry point của function. Nó lấy object envent làm tham số đầu vào và trả về một object response.\nNó tạo ra object params với những yếu tố cần thiết, bao gồm tên của DynamoDB table, thuộc tính của item trong table (user, id, title, bodyText, dueDate, createdAt).\nFunction ghi lại dữ liệu vào DynamoDB table bằng PutCommand và logs ra lời nhắn thành công.\nResponse sẽ trả về một object với statusCode là 200, đặt headers với CORS và body là dữ liệu được ghi lại.\nTóm lại, Đoạn code này phục vụ cho việc tạo và cập nhật task trong DynamoDB table dựa vào việc gửi request API. Nó tận dụng AWS SDK dành cho DynamoDB, Node.js và AWS Lambda để cung cấp giải pháp quản lý tác vụ của serverless và mở rộng quy mô.\nThêm Lambda function vào SAM template Coppy và paste đoạn code dưới đây vào mục Resource trong file template.yml, sau function TasksTable.\nCú pháp trong YAML có phân biệt khoảng trắng, vì vậy hãy chắc chắn rằng phạm vi của function CreateTaskFunction được thụt lề vào sâu hơn so với phạm vi của Resources.\nGiá trị AWS::Serverless::Function được dùng để khởi tạo Lambda function. Thuộc tính CodeUri được dùng để xác định rõ vị trí của file app.js trong thư mục src/handlers/createTask.\n# CreateTask Lambda Function\rCreateTaskFunction:\rType: AWS::Serverless::Function\rProperties:\rCodeUri: src/handlers/createTask\rHandler: app.handler\rPolicies:\r- DynamoDBCrudPolicy:\rTableName: !Ref TasksTable\rEnvironment:\rVariables:\rTASKS_TABLE: !Ref TasksTable\rEvents:\rPostTaskFunctionApi:\rType: Api\rProperties:\rRestApiId: !Ref TasksApi\rPath: /tasks\rMethod: POST\rAuth:\rAuthorizer: MyLambdaTokenAuthorizer Chi tiết và công dụng của các thuộc tính được khai báo ở trên các bạn có thể xem lại ở phần này.\nHãy làm như hình bên dưới.\n"
},
{
	"uri": "/vi/2-prerequiste/2.2-repodisk/",
	"title": "Tăng dung lượng của Cloud9 instance",
	"tags": [],
	"description": "",
	"content": "\rĐầu tiên, chúng ta sẽ cập nhật phiên bản mới nhất của AWS CLI:\npip install --user --upgrade awscli aws-sam-cli Ở trang terminal trên Cloud9, chạy command sau để để clone Git repository aws-serverless-saas-workshop:\ngit clone https://github.com/aws-samples/aws-serverless-saas-workshop.git Sau khi chạy câu lệnh trên, chúng ta sẽ được như hình. Chúng ta sẽ thấy thư mục aws-serverless-saas-workshop được tạo ra.\nKiểm tra dung lượng của Cloud9 instance Mặc định, dung lượng trống của một Cloud9 instance chỉ tầm khoảng 2GB. Dùng đoạn script dưới đây để tránh tình trạng hết dung lượng và vấn đề trong suốt buổi workshop.\nChuyển đến thư mục aws-serverless-saas-workshop, kiểm tra dung lượng của volume hiện tại bằng lệnh sau:\ncd aws-serverless-saas-workshop\rdf -h Chúng ta sẽ nhận được kết quả như hình bên dưới:\nfilesystem ở đường dẫn /dev/nvme0n1p1 là volume mà chúng ta đang sử dụng. Chúng ta sẽ thấy dung lượng trống của Cloud9 instance này là 3.6G. Để tránh tình trạng hết dung lượng trong suốt buổi workshop, chúng ta được yêu cầu tối thiểu 50G cho workshop này, bắt đầu tăng dung lượng của Cloud9 instance này lên 50G.\nCác bạn hãy vào thư mục Cloud9Setup và mở file script increase-disk-size.sh bằng đường dẫn sau:\ncd ~/environment/aws-serverless-saas-workshop/Cloud9Setup/ Sau khi mở file script increase-disk-size.sh, chúng ta sẽ thấy nội dung đoạn script dùng để tăng dung lượng:\nChúng ta tăng dung lượng Cloud9 instance bằng cách chạy file script đó:\n./increase-disk-size.sh Sau khi tăng thành công, chúng ta sẽ nhận được output như hình:\nBây giờ hãy kiểm tra lại dung lượng hiện tại bằng lệnh sau:\ndf -h Và chúng ta sẽ thấy kết quả.\nNhư chúng ta thấy ở đường dẫn /dev/nvme0n1p1, dung lượng hiện tại của Cloud9 instance đã tăng lên 50G.\nThỉnh thoảng, mặc dù dung lượng của Cloud9 instance đã được tăng lên 50G, nó vẫn có thể hiển thị là 10G khi bạn chạy câu lệnh df -h. Trong trường hợp này, hãy restart Cloud9 instance bằng câu lệnh sudo reboot và chạy lại câu lệnh df -h để kiểm tra lại.\n"
},
{
	"uri": "/vi/2-prerequiste/2.3-installtool/",
	"title": "Cài đặt các công cụ cần thiết",
	"tags": [],
	"description": "",
	"content": "\rĐầu tiên, chúng ta sẽ cập nhật phiên bản mới nhất của AWS CLI:\npip install --user --upgrade awscli aws-sam-cli Các bạn hãy vào thư mục Cloud9Setup và mở file script pre-requisites.sh bằng đường dẫn sau:\ncd ~/environment/aws-serverless-saas-workshop/Cloud9Setup/ Sau khi mở file script pre-requisites.sh, chúng ta sẽ thấy nội dung đoạn script dùng để cài đặt toàn bộ các công cụ cần thiết của buổi workshop này:\nChúng ta chạy file script đó để cài đặt, sẽ mất khoảng từ 3 đến 5 phút để hoàn thành:\n./pre-requisites.sh Đoạn script trên sẽ tải và upgrade các công cụ cho Cloud9 IDE của bạn:\nPython 3.8 AWS CLI AWS SAM AWS CDK CLI git-remote-codecommit Node and npm Sau khi chạy script hoàn thành, chúng ta sẽ thấy kết quả như hình bên dưới:\nTiếp theo, vẫn trong đường dẫn đó, chúng ta mở file pre-requisites-versions-check.sh :\nĐoạn script trên sẽ kiểm tra phiên bản của các công cụ đã được cài đặt ở trên có phù hợp với buổi workshop này hay không. Chúng ta chạy file script đó để kiểm tra:\n./pre-requisites-versions-check.sh Hãy chắn rằng kết quả của bạn sẽ nhận được PASS cho tất cả các công cụ được cài đặt và cập nhật:\nThỉnh thoảng, mặc dù đã cài đặt và cập nhật đúng phiên bản nhưng khi chạy script kiểm tra phiên bản nhưng mà nó vẫn chưa cập nhật thì các bạn hãy restart lại Cloud9 instance bằng câu lệnh sudo reboot và chạy lại script kiểm tra phiên bản đó.\n"
},
{
	"uri": "/vi/1-introduce/1.3-whatbuild/",
	"title": "Chúng ta sẽ xây dựng những cái gì?",
	"tags": [],
	"description": "",
	"content": "Trong buổi workshop này, chúng ta sẽ build cấu trúc chồng lên nhau bằng cách thêm dần các thành phần để đạt mục tiêu cuối cùng là xây dựng một ứng dụng SaaS với đầy đủ chức năng.\nDưới đây là kiến trúc mà chúng ta sẽ xây dựng trong buổi workshop này.\nChúng ta sẽ chia kiến trúc này thành 3 phần.\nWeb applications Đây là 3 ứng dụng khác nhau mà chúng ta dùng nó để tương tác với các backend services. Mỗi ứng dụng đó đều được xây dựng bằng Angular.\nỨng dụng SaaS provider admin console dành cho administrators của các nhà cung cấp SaaS Ứng dụng Landing/sign-up application dùng cho những tenants mới đăng ký thành viên. Ứng dụng Sample SaaS commerce application đại diện cho một ứng dụng thương mại điện tử điển hình. Người dùng cần phải đăng nhập vào để sử dụng các tính năng của nó. Shared services Bạn sẽ thấy một tập hợp các dịch vụ được chia sẻ, nó chịu trách nhiệm về việc quản lí người dùng, tenants ở các khía cạnh của ứng dụng. Cái tên shared chuyền tải khái niệm rằng các dịch vụ này là nền tảng cho môi trường SaaS, cung cấp các tính năng cross-cutting tách biệt với các application service của bạn và được chia sẻ với tất cả các tenants. Điều này có nghĩa là tất cả hoạt động và dữ liệu được dùng để tích hợp, quản lí, xác thực và cấu hình cho tenants đều được xử lí bởi share services.\nĐể tìm hiểu nhiều hơn về Share Services, hãy xem tài liệu này, ở đây sẽ có phần Q\u0026amp;A để giải thích những khuất mắt của nó\nApplication services (Tiered Deployment Model) Các application services là đại diện của các microservices, nó cung cấp các chức năng chính cho ứng dụng của bạn. Trong solution này, bạn sẽ thấy rằng chúng ta hỗ trợ mô hình triển khai theo tầng cho các microservices này. Các SaaS provider thường được yêu cầu hỗ trợ nhiều ties mà nó có những yêu cầu khác nhau về isolation, noisy neighbor, performance và những thứ khác. Ý tưởng ở đây là chúng ta sẽ xem xét cân nhắc sử dụng các tiers để hỗ trợ các yêu cầu này. Chúng ta sẽ sử dụng tenant tier để đóng góp vào cách triển khai các microservices cho một tenant nhất định.\nBạn sẽ thấy 3 tiers Basic, Standard, Premium mà tenants sẽ sử dụng mô hình pooled trong đó các tenants chia sẻ AWS resources. Mặt khác, Platinum tier tenants được triển khai với Silo model. Điều này nghĩa là mỗi Platinum tier tenant được hưởng AWS resources của iêng họ, không được chia sẻ với bất kì tenant nào khác.\nĐể tìm hiểu nhiều hơn về Application Services, hãy xem tài liệu này, ở đây sẽ có phần Q\u0026amp;A để giải thích những khuất mắt của nó\n"
},
{
	"uri": "/vi/3-serverless/",
	"title": "Giới thiệu nhanh về ứng dụng web serverless",
	"tags": [],
	"description": "",
	"content": "Tổng quan Mục tiêu của phần này là giới thiệu cho các bạn ứng dụng web cơ bản về serverless và hiểu được cách mà các services AWS Serverless tương tác với nhau. Chúng ta sẽ bắt đầu bước này bằng cách giúp bạn làm quen với các phần chuyển động của environtment của ứng dụng web Serverless nói chung. Trong các phần tiếp theo, bạn sẽ sử dụng ứng dụng web này để thêm các tính năng cần thiết để xây dựng ứng dụng SaaS của chúng ta.\nTrong phần này, chúng ta sẽ sử dụng Serverless Application Model (SAM) để xây dựng một quy trình backend để xử lí các yêu cầu từ ứng dụng web. Bạn sẽ dùng Lambda function để thực hiện mỗi chức năng mà ứng dụng cần, mỗi lần user gửi request đến, nó sẽ được gọi thực thi. Funtion này sẽ lưu trữ dữ liệu vào DynamoDB, sau đó sẽ gửi phản hồi đến phần front-end và cập nhật trên giao diện người dùng. Function được gọi từ trình duyệt bằng Amazon API Gateway.\nSAM là gì? Serverless Application Model (SAM) là một open-source framework nó sẽ giúp việc triển khai serverless application trở nên dễ dàng hơn. Nó cung cấp một cách đơn giản để định nghĩa các serverless application, và cung cấp một tập các công cụ để triển khai các ứng dụng đó.\nNó cho phép chúng ta xác định rõ những yêu cầu của ứng dụng bằng code. SAM chuyển đổi và mở rộng SAM syntax lên AWS Cloudformation để triển khai ứng dụng của bạn. Bạn sẽ thấy và sử dụng SAM templates throughout this workshop.\nSAM hoạt động như thế nào? AWS SAM dựa trên AWS Cloudformation. Một ứng dụng serverless được định nghĩa bằng một CloudFormation template và được triển khai với CloudFormation stack. Tóm lại, AWS SAM template là CloudFormation template.\nAWS SAM xác định một tập hợp tài nguyên mô tả các components chung của ứng dụng serverless. Để AWS SAM có những objects được định nghĩa trong CloudFormation template thì template đó phải gồm phần Transform trong document root là AWS::Serverless-2016-10-31.\nTrong bài này chúng ta sẽ không đi sâu vào phân tích triển khai một ứng dụng web Serverless với SAM template, nên nếu bạn chưa có kiến thức gì về SAM template thì hãy tham khảo ở đây để nắm rõ cấu trúc và nội dụng của các file mà mình sẽ chỉ việc chạy script để không mất nhiều thời gian trong bài workshop này.\nBên dưới là kiến trúc hạ tầng của ứng dụng web này.\nKhi nhìn vào kiến trúc hạ tầng này, bạn sẽ thấy chúng ta có một ứng dụng web ở phía bên trái. Nó đại diện cho ứng dụng để người dùng được sử dụng và trải nghiệm nó. Nó sẽ được truy cập bằng Amazon CloudFront distribution. Distribution này sẽ lấy resource của ứng dụng từ Amazon S3 bucket. Ứng dụng của chúng tôi truy cập vào các microservices của environment thông qua API Gateway. API Gateway này sẽ xử lí từng yêu cầu và route các traffic đến các chức năng thích hợp trong mỗi microservice của ứng dụng. Đối với ví dụ này, chúng ta đã có 2 e-commerce microservices, Product và Orrder, được cũng cấp các chức năng CRUD cơ bản. Mỗi service này sử dụng Amazon DynamoDB để lưu trữ và quản lí dữ liệu. Nhìn chung, kiến trúc hạ tầng này bao gồm tất cả các yếu tố cơ bản tạo thành một ứng dụng web serverless cơ bản. Tuy nhiên, ở giai đoạn này, solution này sẽ không hỗ trợ cho multi-tenant. Trong tương lai, chúng ta sẽ tìm hiểu và bổ sức các tính năng phục vụ cho multi-tenant.\nServerless microservices Khái niệm về microservice có thể hơi khác một chút đối với serverless environment. Đúng là mỗi chứng năng có thể là microservice. Tuy nhiên, phổ biến hơn là có một tập hợp các functions đại diện cho một logical microservice. Trong trường hợp này, ranh giới microservice là API Gateway, được hỗ trợ bởi một hoặc nhiều Lambda functions. Như trong kiến trúc hạ tầng ở trên, Order service được chia thành nhiều functions như create, get, update và delete. Những functions này đều hoạt động trên cùng một dữ liệu và được nhóm lại với nhau thành một logical microservice.\nCuối cùng, chúng ta đã sử dụng Amazon DynamoDB để lưu trữ dữ liệu của mình và Amazon CloudWatch để lưu trữ tất cả các logs của ứng dụng.\nNội dung Khai báo Table trong DynamoDB Tạo Lambda function "
},
{
	"uri": "/vi/5-deploy/5.3-initializeamplify/",
	"title": "Khởi tạo Amplify",
	"tags": [],
	"description": "",
	"content": "Bước này, chúng ta sẽ set up Amplify để có thể khởi tạo những service cần thiết cho phần backend của ứng dụng. Chúng ta sẽ đi cấu hình cho Amplify hosting.\nChạy lệnh sau để vào thư mục root của web project (/webapp):\ncd ~/environment/serverless-tasks-webapp/webapp Chúng ta khởi tạo Amplify:\namplify init Chúng ta sẽ đặt tên cho project là tasks và nhấn Enter để tiếp tục. Nó sẽ hiện ra những thông tin về project.\nTiếp theo, nó sẽ hỏi chúng ta có muốn khởi tạo project với những thông tin như trên hay không thì nhập Y và nhấn Enter.\nSau đó, nó sẽ hỏi chúng ta chọn cách xác thực mà chúng ta muốn, chúng ta chọn AWS profile và nhấn Enter. Và chọn profile mặc định mà chúng ta đã cấu hình ở bước trước đó.\nChúng ta sẽ làm như hình dưới đây.\nCLI có thể tự xác định được cấu hình phù hợp với project mà Amplify được khởi tạo. Trong workshop này, CLI biết chúng ta đang sử dụng Vue.js và cung cấp cấu hình phù hợp với app type, framework, source, distribution, build và start options.\nKhi chúng ta khởi tạo project Amplify mới, sẽ có một vài thứ thay đổi:\nNó sẽ tạo ra một thư mục mới có tên là amplify trong thư mục root của project và chứa những khởi tạo của backend. Nó tạo ra một file tên là aws-exports.js trong thư mục src của project. File này chứa những thông tin cấu hình cần thiết cho những services mà bạn tạo ra với Amplify, đây là cách mà người dùng Amplify có thể lấy những thông tin cần thiết của những backend services. Những cloud project được tạo ra trong AWS Amplify Console có thể được truy cập bằng cách chạy lệnh amplify console. Console cung cấp danh sách các môi trường backend, những resources được thực thi trong Amplify category, trang trái hiện tại của deployments và những thông tin khác. Quá trình khởi tạo Amplify hoàn thành, chúng ta sẽ nhận được thông báo như hình dưới đây.\nBây giờ, ứng dụng Vue.js đã được thiết lập và Amplify đã được khởi tạo, chúng ta đã sẵn sàng để sử dụng Amplify hosting ở bước tiếp theo.\n"
},
{
	"uri": "/vi/5-deploy/5.4-buildapp/",
	"title": "Build ứng dụng web",
	"tags": [],
	"description": "",
	"content": "\rĐầu tiên, hãy đảm bảo rằng bạn đang ở thư mục gốc của project (/webapp)\ncd ~/environment/serverless-tasks-webapp/webapp Tiếp theo, cài đặt các dependencies cần thiết cho project bằng lệnh sau:\nnpm install Chúng ta sẽ thấy như hình sau khi cài đặt xong:\nBỏ qua những cảnh báo về bảo mật khi chạy câu lệnh npm install trong phạm vi buổi workshop này. Trong môi trường production thực tế, chúng ta sẽ xử lí chúng trước đó.\nSau khi cài đặt xong, chúng ta sẽ build ứng dụng web bằng lệnh sau:\nnpm run build Nếu build thành công, chúng ta sẽ nhận được như này:\n"
},
{
	"uri": "/vi/4-apigateway/",
	"title": "Giới thiệu nhanh về ứng dụng web serverless",
	"tags": [],
	"description": "",
	"content": "Mục tiêu của phần này là giới thiệu cho các bạn ứng dụng web cơ bản về serverless và hiểu được cách mà các services AWS Serverless tương tác với nhau. Chúng ta sẽ bắt đầu bước này bằng cách giúp bạn làm quen với các phần chuyển động của environtment của ứng dụng web Serverless nói chung. Trong các phần tiếp theo, bạn sẽ sử dụng ứng dụng web này để thêm các tính năng cần thiết để xây dựng ứng dụng SaaS của chúng ta.\nLambda Authorizer là gì? Lambda authorizer là một tính năng của API Gateway mà nó sử dụng Lambda function để kiểm soát truy cập tới API của bạn. Đó là một cách để bổ sung bảo mật cho API của bạn.\nLambda Authorizer hoạt động như thế nào? Khi client gửi request đến một trong những chức năng của API thì API Gateway sẽ gọi đến Lambda authorizer để xác thực client và trả về IAM policy để kiểm tra client đó có được quyền truy cập hay không.\nAPI Gateway hỗ trợ các tiêu chuẩn mở cho các cách xác thực như OAuth và SAML.\nThông thường, intentity provider được sử dụng để xác thực người gửi request đến API. Identity provider phải chịu trách nhiệm xác minh và trả về danh tính của người đó. Sau đó, nó sẽ được chuyến đền Lambda authorizer, nơi chịu trách nhiệm kiểm soát quyền truy cập API của bạn.\nTrong workshop này, chúng ta sẽ không triển khai identity provided, vì vậy, thay vào đó, chúng ta sẽ mock identity provider.\nJSON Web Token (JWT) Danh tính của người gọi API sẽ được biểu diễn bằng một JSON Web Token (JWT). Theo wikipedia, \u0026ldquo;A JWT is a compact, self-contained, signed JSON object. The JWT is typically used to represent an authenticated user\u0026rsquo;s identity.\u0026rdquo;\nExample JWT Một JWT token bao gồm 3 phần: header, payload và signature. Phần header và payload là những đối tượng dạng JSON. Phần signature là một chuỗi kí tự được sử dụng để xác thực phần header và payload.\nHeader: Loại token (typ) là JWT. Thuật toán (alg) là HS256, là sự kết hợp giữa HMAC cùng với SHA-256\n{\r\u0026#34;typ\u0026#34;: \u0026#34;JWT\u0026#34;,\r\u0026#34;alg\u0026#34;: \u0026#34;HS256\u0026#34;\r} Payload: Thuộc tính iss là tên của identity provider. Thuộc tính sub là tên của người gửi request. Thuộc tính scope là quyền của người gửi request. Thuộc tính jti là unique identifier cho JWT. Thuộc tính iat là thời gian mà token được tạo ra. Thuộc tính exp là thời gian mà token hết hạn.\n{\r\u0026#34;iss\u0026#34;: \u0026#34;getting-started-with-serverless\u0026#34;,\r\u0026#34;sub\u0026#34;: \u0026#34;minhnghia\u0026#34;,\r\u0026#34;scope\u0026#34;: \u0026#34;admins\u0026#34;,\r\u0026#34;jti\u0026#34;: \u0026#34;02343566e-8ff3-4a2d-ac18-c4d28ed96881\u0026#34;,\r\u0026#34;iat\u0026#34;: 1633433217,\r\u0026#34;exp\u0026#34;: 4070208800\r} Signature: R2D2RfY_n7OAcuONbpPfxqBY5IppEiGLCCfeQ_wz_2w Các giá trị này đều được mã hóa dạng base64 và nối với form của JWT bằng dấu \u0026ldquo;.\u0026rdquo;, ví dụ như sau:\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJsb2dnZWRJbkFzIjoiYWRtaW4iLCJpYXQiOjE0MjI3Nzk2Mzh9.gzSraSYS8EXBxLN_oWnFSRgCzcmJmMjLiuyu5CSpyHI Bạn sẽ thấy token được gửi đến API Gateway endpoint bằng ứng dụng web và sử dụng HTTP Authorization header.\nCấu hình Lambda Authorizer Coppy đoạn code dưới đây và paste vào file app.js trong thư mục sam/src/auth.\nconst jwt = require(\u0026#39;njwt\u0026#39;)\rexports.handler = function (event, context, callback) {\rconsole.info(\u0026#39;received:\u0026#39;, event)\rconst token = event.authorizationToken.split(\u0026#39; \u0026#39;)[1]\rjwt.verify(token, \u0026#39;secretphrase\u0026#39;, (err, verifiedJwt) =\u0026gt; {\rif (err) {\rconsole.log(err.message)\rcallback(\u0026#39;Error: Invalid token\u0026#39;)\r} else {\rconsole.log(`Verified token: ${verifiedJwt}`)\rconst resource = `${event.methodArn.split(\u0026#39;/\u0026#39;, 2).join(\u0026#39;/\u0026#39;)}/*`\rconst policy = generatePolicy(verifiedJwt.body.sub, \u0026#39;Allow\u0026#39;, resource)\rconsole.log(`Generated policy: ${JSON.stringify(policy)}`)\rcallback(null, policy)\r}\r})\r}\rconst generatePolicy = function (principalId, effect, resource) {\rconst authResponse = {}\rauthResponse.principalId = principalId\rif (effect \u0026amp;\u0026amp; resource) {\rconst policyDocument = {}\rpolicyDocument.Version = \u0026#39;2012-10-17\u0026#39;\rpolicyDocument.Statement = []\rconst statementOne = {}\rstatementOne.Action = \u0026#39;execute-api:Invoke\u0026#39;\rstatementOne.Effect = effect\rstatementOne.Resource = resource\rpolicyDocument.Statement[0] = statementOne\rauthResponse.policyDocument = policyDocument\r}\rauthResponse.context = {\ruserId: 1,\rcreatedAt: new Date().toISOString()\r}\rreturn authResponse\r} Đoạn code phía trên sẽ xác minh và xác thực những request được gửi đến API bằng cách sử dụng JSON Web Token (JWT) và trả về một IAM policy cho người được xác thực đó.\nBắt đầu, chúng ta sẽ import thư viện njwt, nó được dùng cho xác thực JWT.\nexports.handler là entry point của Lambda function. Nó sẽ nhận vào một event, một context và một callback. Event chứa các thông tin về request gửi đến API. Context chứa các thông tin về Lambda function. Callback sẽ được gọi khi Lambda function hoàn thành.\nJWT token được trích xuất từ authorizationToken trong phần header của request. Sẽ có một phương thức phân tách được sử dùng để xóa tiền tố Bearer và truy xuất mã token thực sự.\nHàm jwt.verify được sử dụng để xác minh token bằng cách sử dụng secretphrase. Nếu token không hợp lệ, Lambda function sẽ trả về một lỗi. Nếu token hợp lệ, object JWT được xác thực đó sẽ được lấy đi và xử lí.\nBiến resource được đặt để đại diện cho những resource được yêu cầu từ API request.\nHàm generatePolicy được sử dụng để tạo ra một IAM policy. Nó sẽ lấy giá trị của sub (subject) từ body của JWT, chuyển effect thành Allow và sử dụng biến resource để làm rõ policy đó.\nTóm lại, đoạn code ở trên là một phương thức xác thực đơn giản dựa vào token, nó dùng để mô tả cách sử dụng token để xác thực request. Token được truyền bằng header của Authorization. Sau đó chúng ta sẽ xác minh token bằng cách sử dụng (secretphrase). Đó là một passphrase rất phổ biến, được áp dụng trong ứng dụng web. Chúng ta chỉ đơn giản là mock identity provider. Trong thực tế, chúng ta sẽ sử dụng một identity provider uy tín, chẳng hạn như Amazon Cognito, để xác minh danh tính của người dùng.\nIAM Policy Document Đây là ví dụ về IAM policy document được trả về tới người gọi. Ở đây, principal minhnghia được cấp quyền truy cập đến các method của API Gateway.\n{\r\u0026#34;principalId\u0026#34;: \u0026#34;minhnghia\u0026#34;,\r\u0026#34;policyDocument\u0026#34;: {\r\u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;,\r\u0026#34;Statement\u0026#34;: [\r{\r\u0026#34;Action\u0026#34;: \u0026#34;execute-api:Invoke\u0026#34;,\r\u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;,\r\u0026#34;Resource\u0026#34;: \u0026#34;arn:aws:execute-api:us-east-1:0123456789012:dn3fidb5ng0/v1/*\u0026#34;\r}\r]\r},\r\u0026#34;context\u0026#34;: {\r\u0026#34;userId\u0026#34;: 1,\r\u0026#34;createdAt\u0026#34;: \u0026#34;2021-10-01T19:53:34.594Z\u0026#34;\r}\r} principalId đại diện cho indentify của người dùng được gán với request. Trong đoạn code này, nó được gán giá trị minhnghia, IAM policy này được gán với người dùng này cùng identifier là minhnghia.\nobject policyDocument xác định quyền được gán trong policy. Version là phiên bản của ngôn ngữ viết policy đang được sử dụng hiện tại là 2012-10-17. Statement là một mảng các quyền được gán cho người dùng. Trong đoạn code này, nó chỉ có một quyền duy nhất là execute-api:Invoke. Effect là một trong hai giá trị Allow hoặc Deny. Resource là một định danh duy nhất cho một resource cụ thể. Trong đoạn code này, nó là một định danh cho một API Gateway endpoint.\ncontext là một object chứa các thông tin bổ sung về người dùng. Nó có thể được sử dụng để truyền các thông tin bổ sung về người dùng đến Lambda function. Trong đoạn code này, nó chứa hai thông tin là userId và createdAt. Cái này có lợi trong việc debugging và kiểm tra các request của người dùng đó.\n"
},
{
	"uri": "/vi/1-introduce/1.4-serverlessused/",
	"title": "Những service Serverless được sử dụng",
	"tags": [],
	"description": "",
	"content": "Dưới đây là danh sách các AWS services và tính năng mà buổi workshop này sử dụng:\nAWS Serverless Application Model (SAM) là một open-source framework để xây dựng các ứng dụng serverless. Nó cung cấp các syntax ngắn để thực hiện các chức năng, APIs, cơ sở dữ liệu và event source mappings. Chỉ với một vài dòng trên mỗi resource, bạn có thể định nghĩa được ứng dụng mà mình muốn và mô hình sử dụng YAML. Trong suốt quá trình deployment, SAM biến đổi và mở rộng cú pháp thành AWS CloudFormation cho phép bạn xây dựng các ứng dụng serverless nhanh hơn.\nAWS Cloud Development Kit (CDK) là open-source software development framework để định nghĩa các cloud infrastructure dưới dạng code và provision nó bằng AWS CloudFormation. Nó cho phép bạn sử dụng các ngôn ngữ lập trình như TypeScript, JavaScript, Python, Java, C#/.Net để định nghĩa các AWS resources trong một ứng dụng. CDK sẽ biến đổi các ngôn ngữ lập trình này thành CloudFormation template và deploy nó lên AWS.\nAmazon API Gateway là một fully managed service để tạo, quản lí, monitor và bảo mật các API ở bất kì quy mô nào. Nó cung cấp các tính năng như API creation, publishing, maintenance, monitoring, và securing. Nó cũng cho phép bạn tạo các RESTful APIs và WebSocket APIs để truyền tải dữ liệu ở bất kì quy mô nào.\nREST APIs là một dạng API mà nó sử dụng HTTP requests để truyền tải dữ liệu. REST APIs có thể truyền tải dữ liệu ở bất kì định dạng nào như JSON, XML, HTML, text, etc. Lambda Authorizer là một cách để bảo mật các REST APIs bằng cách sử dụng Lambda function để xác thực các yêu cầu API. Lambda authorizers có thể được sử dụng để xác thực các yêu cầu API bằng cách sử dụng bearer token, request parameters, headers, và client certificates. Usage Plans là một cách để quản lí các yêu cầu API của bạn. Nó cho phép bạn quản lí các yêu cầu API bằng cách sử dụng API keys và rate limits. API keys là một cách để bảo mật các REST APIs bằng cách sử dụng API keys. API keys có thể được sử dụng để bảo mật các REST APIs bằng cách sử dụng các API keys. Amazon Cognito là một fully managed service để xác thực, quản lí người dùng và đồng bộ hóa dữ liệu người dùng trên các thiết bị. Nó cung cấp các tính năng như sign-up, sign-in, và access control cho các ứng dụng web và mobile. Nó cũng cho phép bạn đồng bộ hóa dữ liệu người dùng trên các thiết bị.\nUser Pools là một cách để xác thực và quản lí người dùng. Nó cung cấp các tính năng như sign-up, sign-in, và access control cho các ứng dụng web và mobile. AWS Lambda là một service serverless compute cho phép bạn chạy code mà không cần phải provision hay manage các servers. Lambda cung cấp một cách để chạy code mà không cần phải quản lí các servers. Nó cũng cung cấp các tính năng như auto scaling, high availability, và native integrations với một số service khác của AWS.\nAmazon DynamoDB là một cặp key-value serverless và là một loại cơ sở dữ liệu phi quan hệ (Non-SQL) mang lại hiệu suất một phần nghìn giây ở mọi quy mô. Tương tự với những cơ sở dữ liệu khác, Amazon DynamoDB sẽ lưu trữ data bằng các bảng. Trong ứng dụng của chúng ta, chúng ta sẽ lưu trữ thông tin của các tasks trong bảng của DynamoDB. Bảng này sẽ được truy cập bằng Lambda function bằng sự phản hồi đến API từ ứng dụng web của chúng ta.\nThêm vào đó, chúng ta sẽ lựa chọn và sử dụng ngôn ngữ lập trình chính là Python trong buổi workshop này.\n"
},
{
	"uri": "/vi/2-prerequiste/2.4-cloudwatch/",
	"title": "Thiết lập role ARN của CloudWatch log cho API Gateway",
	"tags": [],
	"description": "",
	"content": "\rĐầu tiên, chúng ta sẽ cập nhật phiên bản mới nhất của AWS CLI:\npip install --user --upgrade awscli aws-sam-cli Ở bước này, trong account AWS của chúng ta, chúng ta sẽ đảm bảo role ARN của CloudWatch log được thiết lập cho API Gateway. Bạn cần bước thiết lập này để chắc chắn API Gateway có thể ghi log vào CloudWatch để có thể debug errors của API Gateway REST APIs.\nAPI Gateway - REST API Nhập API Gateway ở thanh tìm kiếm service trên AWS Console sau đó chọn API Gateway.\nNếu đây là lần đầu bạn sử dụng API Gateway, bạn sẽ thấy trang giới thiệu các tính năng của API Gateway. Dưới REST API, ta chọn Build. Khi popup Create Example API xuất hiện, ta chọn OK.\nNếu như đây không phải là lần đầu sử dụng API Gateway, ta chọn Create API ở góc trên bên phải của trang.\nỞ trang Choose an API type, ta chọn loại REST API nhưng không phải Private và chọn Build.\nỞ trang Choose the protocol, chúng ta sẽ chọn giao thức của nó, chúng ta chọn REST, ở phần Create new API, chúng ta chọn Example API, nó sẽ hiện ra một example API, chúng ta có thể xem chi tiết về nó.\nVà cuối cùng là nhấn nút Import, nó sẽ tạo ra API mới.\nAPI mới sẽ được hiển thị ở đây với cái tên là PetStore.\nĐể biết thêm về cách sử dụng API đó, các bạn sẽ xem ở đây: Example REST API\nTạo CloudWatch role Bước tiếp theo, chúng ta sẽ tạo role ARN cho phép CloudWatch ghi lại log của cách hành động gửi yêu cầu đến API.\nĐầu tiên chúng ta sẽ vào AWS Identity and Access Management (IAM) console, ở thanh điều hướng bên trái, chúng ta chọn Roles.\nClick vào nút Create role.\nỞ trang Create role, phần Trusted entity type, chúng ta chọn AWS service, ở phần Use case, chúng ta sẽ click vào drop box Use cases for other AWS services, chúng ta chọn API Gateway và nhần nút Next.\nỞ trang Add permissions, chúng ta sẽ thấy policy AmazonAPIGatewayPushToCloudWatchLogs đã được chọn sẵn. Policy này có tất cả các quyền chúng ta cần.\nCuối cùng ở trang Name, review, and create, chúng ta đặt tên cho nó ở phần Role name, ở đây mình sẽ đặt là cloudwatch-api. Những mục khác chúng ta để mặt định, nhấn nút Create role. Vậy là chúng ta đã tạo thành công.\nQuay trở lại trang Role, nhập vào thanh tìm kiếm cloudwatch-api nó sẽ hiện thị role mình vừa tạo.\nChúng ta click vào role cloudwatch-api để xem chi tiết. Chúng ta sẽ thấy giá trị ARN của role đó và coppy nó để dùng cho bước tiếp theo.\nQuay trở lại trang API Gateway console, chọn API có tên là PetStore sau đó ở thanh điều hướng bên trái, ở dưới Client Certificates, chúng ta chọn Settings. Ở phần CloudWatch log role ARN, chúng ta paste ARN của role cloudwatch-api vào và nhấn nút Save.\nVậy là chúng ta đã hoàn thành việc thiếp lập CloudWatch log role ARN cho API Gateway. Hãy cùng đi đến bước tiếp theo.\n"
},
{
	"uri": "/vi/5-deploy/",
	"title": "Build và deploy ứng dụng web: AWS Amplify",
	"tags": [],
	"description": "",
	"content": "Tổng quan Trong bước này, bạn sẽ xây dựng và triển khai ứng dụng serverless sử dụng SAM. Tiếp đó, bạn sẽ cấu hình ứng dụng web để tương tác với API Gateway endpoint. Sau đó, bạn sẽ build ứng dụng web và cấu hình AWS Amplify để host các static resource cho ứng dụng web của bạn.\nNội dung Deploy Serverless Application Cấu hình API Gateway endpoint Khởi tạo Amplify Build ứng dụng web Thêm Amplify Hosting vào ứng dụng Deploy ứng dụng "
},
{
	"uri": "/vi/1-introduce/1.5-prior/",
	"title": "Kiến thức cần nắm rõ",
	"tags": [],
	"description": "",
	"content": "Buổi workshop này nhằm mục đích đưa ra giải pháp các trường hợp về xây dựng ứng dụng dựa vào SaaS sử dụng các dịch vụ AWS Serverless. Mặc dù không bắt buộc nhưng bạn sẽ thu thập được nhiều kiến thức, kinh nghiệm từ buổi workshop này nếu bạn đã có kiến thức cơ bản về AWS và Serverless. Đối với những người mới tiếp cận Serverless trên AWS, chúng ta sẽ cố gắng cung cấp tổng quát về cách xây dựng ứng dụng web Serverless cơ bản vì buổi workshop này không chú trọng việc giới thiệu kĩ càng về các dịch vụ AWS Serverless.\n"
},
{
	"uri": "/vi/5-deploy/5.5-amplifyhosting/",
	"title": "Thêm Amplify Hosting vào ứng dụng",
	"tags": [],
	"description": "",
	"content": "Chúng ta đã thành công build ứng dụng với Amplify! Bây giờ sau khi build xong, chúng ta sẽ deploy nó lên web bằng Amplify Console.\nTất cả static resource của ứng dụng web bao gồm HTML, CSS, JavaScript, images và những file khác sẽ được quản lí bởi AWS Amplify Console. Người dùng sẽ truy cập vào ứng dụng thông qua URL public được cấp bởi Amplify Console. Bạn không cần khởi chạy bất kì web servers hoặc những services khác để làm cho ứng dụng của bạn hoạt động.\nTrong thực tế, bạn sẽ sử dụng custom domain để làm chủ ứng dụng. Nếu bạn muốn sử dụng domain của bạn, hãy theo dõi cách thiết lập custom domain trên Amplify\nChạy câu lệnh dưới đây để thêm Amplify Hosting vào ứng dụng web của bạn:\namplify add hosting Khi nó hỏi bạn chọn plugin để thực thi, hãy chọn Hosting with Amplify Console. Tiếp đến, chọn phương thức deployment, các bạn hãy chọn Manual deployment. Vậy là chúng ta đã thêm Amplify Hosting vào ứng dụng web của mình, các bạn tham khảo hình bên dưới.\nTiếp theo, chúng ta sẽ publish ứng dụng lên web.\n"
},
{
	"uri": "/vi/6-test/",
	"title": "Chạy thử ứng dụng",
	"tags": [],
	"description": "",
	"content": "\nSau khi đăng nhập với bất kì username hay password nào, bạn có thể tạo task mới bằng cách nhập Title và Body. Phần Due date có thể để trống.\nNhấn Create để tạo task mới, nó sẽ được hiển trị trong phần My Tasks.\nNhư các bạn sẽ thấy ở hình bên dưới.\nKhi bạn click vào nút Create task, sẽ có những thứ hoạt động:\nRequest với phương thức POST được gửi đến API Gateway endpoint /tasks. Request đó được xác thực bởi Lambda authorizer, sử dụng HTTP header Authentication: Bearer \u0026lt;token\u0026gt;. Body của request đó được chuyển đến Lambda function CreateTaskFunction. Những thông tin của task được nhập ở trên sẽ được lưu trữ ở DynamoDB table. Sẽ có phản hồi với HTTP status code 200 được trả về ứng dụng web. Ứng dụng web refresh lại danh sách các tasks bởi vì request với phương thức GET được gửi đến API Gateway endpoint /tasks. Lại lần nữa, request đó được xác thực bởi Lambda authorizer và chuyển đến Lambda function GetTasksFunction. Lambda function GetTasksFunction truy xuất danh sách các task từ DynamoDB table và trả về danh sách các task đó cho người dùng đã được xác thực. Hãy tạo thêm nhiều tasks mới và thử xóa một task để hiểu rõ hơn về quy trình request được xử lí.\nNội dung Quản lí dữ liệu trong DynamoDB Logging và Monitoring "
},
{
	"uri": "/vi/5-deploy/5.6-deployapp/",
	"title": "Deploy ứng dụng",
	"tags": [],
	"description": "",
	"content": "Trong bước này, chúng ta sẽ publish ứng dụng với amplify bằng câu lệnh sau:\namplify publish Và nếu các bạn nhận được output giống như hình, các bạn đã deploy thành công ứng dụng của mình lên web.\nSau khi publish, ở cuối trang terminal sẽ hiển thị URL của app chúng ta với domain amplifyapp.com\nBạn có thể đăng nhập với bất kì username và password nào mà bạn muốn bởi vì chưa có phần xác thực ở phía backend.\nNếu bạn muốn tìm hiểu cách thêm xác thực vào ứng dụng của mình, hãy truy cập tại đây\nTrang chính của ứng dụng chúng ta sẽ trông như thế này.\nBất cứ khi nào chúng ta muốn thay đổi gì ở ứng dụng và publish nó, chỉ cần chạy lại câu lệnh amplify publish. Chúng ta sẽ không cần modify ứng dụng web, chỉ cần modify ở SAM template và Lambda functions.\nĐể quản lí ứng dụng và cấu hình hosting ở Amplify Console, hãy chạy câu lệnh amplify console.\n"
},
{
	"uri": "/vi/7-rekognition/",
	"title": "Cấu hình cho trích xuất metadata từ hình ảnh: Amazon Rekognition",
	"tags": [],
	"description": "",
	"content": "Amazon Rekognition là gì? Amazon Rekognition giúp chúng ta dễ dàng tải hình ảnh và video và phân tích cho ứng dụng của bạn bằng cách sử dụng công nghệ deep learning (khi sử dụng không cần phải có chuyên môn ở mảng machine learning). Với Amazon Rekognition, bạn có thể xác định objects, people, text, scenes và các activities trong ảnh và videos.\nỞ bước này, chúng ta sẽ thêm tính năng dò tìm những objects của ảnh được tải lên và gán labels cho những objects đó.\nCấu hình Amazon Rekognition Integration Vào thư mục sam/src/handlers/detectLabels và mở file app.js. Coppy đoạn code dưới đây và past vào file đó:\nconst { DynamoDBClient } = require(\u0026#39;@aws-sdk/client-dynamodb\u0026#39;)\rconst { DynamoDBDocumentClient, UpdateCommand } = require(\u0026#39;@aws-sdk/lib-dynamodb\u0026#39;)\rconst { RekognitionClient, DetectLabelsCommand } = require(\u0026#39;@aws-sdk/client-rekognition\u0026#39;)\rconst ddbClient = new DynamoDBClient()\rconst ddbDocClient = DynamoDBDocumentClient.from(ddbClient)\rconst rekognitionClient = new RekognitionClient()\rconst tableName = process.env.TASKS_TABLE\rexports.handler = async (event) =\u0026gt; {\rconsole.info(JSON.stringify(event, null, 2))\rconst bucket = event.Records[0].s3.bucket.name\rconst key = decodeURIComponent(event.Records[0].s3.object.key.replace(/\\+/g, \u0026#39; \u0026#39;))\rconst user = key.split(\u0026#39;/\u0026#39;)[0]\rconst taskId = key.split(\u0026#39;/\u0026#39;)[1]\rconst command = new UpdateCommand({\rTableName: tableName,\rKey: { user: `user#${user}`, id: `task#${taskId}` },\rUpdateExpression: \u0026#39;SET upload = :u\u0026#39;,\rExpressionAttributeValues: {\r\u0026#39;:u\u0026#39;: `s3://${bucket}/${key}`\r},\rReturnValues: \u0026#39;UPDATED_NEW\u0026#39;\r})\rconsole.log(`UpdateCommand: ${JSON.stringify(command, null, 2)}`)\rtry {\rconsole.log(`Saving upload for task ${taskId}: s3://${bucket}/${key}`)\rconst data = await ddbDocClient.send(command)\rconsole.log(\u0026#39;UpdateItem succeeded:\u0026#39;, JSON.stringify(data, null, 2))\r} catch (err) {\rconsole.log(\u0026#39;Unable to update item. Error JSON:\u0026#39;, JSON.stringify(err, null, 2))\rthrow err\r}\rconsole.log(`Detecting labels for bucket ${bucket} and key ${key}`)\rconst imageParams = {\rImage: {\rS3Object: {\rBucket: bucket,\rName: key\r}\r}\r}\rconst labelData = await rekognitionClient.send(\rnew DetectLabelsCommand(imageParams)\r)\rconsole.log(\u0026#39;Success, labels detected.\u0026#39;, labelData)\rconst labels = []\rfor (let j = 0; j \u0026lt; labelData.Labels.length; j++) {\rconst name = labelData.Labels[j].Name\rlabels.push(name)\r}\rconsole.log(`Label data: ${JSON.stringify(labels)}`)\rconst updateLabelsCommand = new UpdateCommand({\rTableName: tableName,\rKey: { user: `user#${user}`, id: `task#${taskId}` },\rUpdateExpression: \u0026#39;SET labels = :s\u0026#39;,\rExpressionAttributeValues: {\r\u0026#39;:s\u0026#39;: labels\r},\rReturnValues: \u0026#39;UPDATED_NEW\u0026#39;\r})\rtry {\rconsole.log(`Saving labels for task ${taskId}: ${labels}`)\rconst data = await ddbDocClient.send(updateLabelsCommand)\rconsole.log(\u0026#39;UpdateItem succeeded:\u0026#39;, JSON.stringify(data, null, 2))\r} catch (err) {\rconsole.log(\u0026#39;Unable to update item. Error JSON:\u0026#39;, JSON.stringify(err, null, 2))\rthrow err\r}\rconst response = {\rstatusCode: 200,\rheaders: {\r\u0026#39;Access-Control-Allow-Origin\u0026#39;: \u0026#39;*\u0026#39;\r},\rbody: JSON.stringify(labels)\r}\rreturn response\r} Chức năng chính của đoạn code trên:\nĐoạn code import AWS SDK và khởi tạo các client cho DynamoDB và Rekognition. Lấy biến môi trường TASKS_TABLE để tạo ra một biến tên tableName. Function trích xuất thông tin liên quan đến event object. Nó truy xuất buckect và filename của object được tải lên trong S3 bucket. Nó tách các key ra để lấy người dùng và ID của task liên kết với object được tải lên. UpdateCommand được tạo ra để cập nhật item trong DynamoDB. Command được log ở console cho mục đích debug. const command = new UpdateCommand({\rTableName: tableName,\rKey: { user: `user#${user}`, id: `task#${taskId}` },\rUpdateExpression: \u0026#39;SET upload = :u\u0026#39;,\rExpressionAttributeValues: {\r\u0026#39;:u\u0026#39;: `s3://${bucket}/${key}`\r},\rReturnValues: \u0026#39;UPDATED_NEW\u0026#39;\r})\rconsole.log(`UpdateCommand: ${JSON.stringify(command, null, 2)}`) Funtion chạy đến UpdateCommand để cập nhật item trong DynamoDB. Nó log message khi lưu thông tin của object được tải lên và URL của object đó. Nếu cập nhật thành công, sẽ có response được log. Nếu không, sẽ có error được log và throw ra. try {\rconsole.log(`Saving upload for task ${taskId}: s3://${bucket}/${key}`)\rconst data = await ddbDocClient.send(command)\rconsole.log(\u0026#39;UpdateItem succeeded:\u0026#39;, JSON.stringify(data, null, 2))\r} catch (err) {\rconsole.log(\u0026#39;Unable to update item. Error JSON:\u0026#39;, JSON.stringify(err, null, 2))\rthrow err\r} Function được thực thi để detect các label của hình ảnh được tải lên bằng Amazon Rekognition. Nó log thông báo của hành động detec label trong bucket. Object imageParams được tạo ra để xác định hình ảnh (S3 object) được detect label. DetectLabelsCommand được tạo ra để gọi Rekognition API để detect label của hình ảnh. Các detected label được lưu trữ trong mảng các labels. console.log(`Detecting labels for bucket ${bucket} and key ${key}`)\rconst imageParams = {\rImage: {\rS3Object: {\rBucket: bucket,\rName: key\r}\r}\r}\rconst labelData = await rekognitionClient.send(\rnew DetectLabelsCommand(imageParams)\r)\rconsole.log(\u0026#39;Success, labels detected.\u0026#39;, labelData)\rconst labels = []\rfor (let j = 0; j \u0026lt; labelData.Labels.length; j++) {\rconst name = labelData.Labels[j].Name\rlabels.push(name)\r} Tóm lại, Lambda function này xử lí các sự kiện khi có object được tải lên trong S3 bucket. Nó cập nhật item trong DynamoDB với thông tin được tải lên như S3 URL. Sau đó, nó sử dụng Amazon Rekognition để detect labels trong hình ảnh và cập nhật item trong DynamoDB với các detected labels. Function phản hồi bằng một object dạng JSON bao gồm detected labels.\nTiếp theo chúng ta cần thêm một resource mới AWS::Serverless::Function vào file template.yaml trong thư mục sam, trong mục Resources, dưới function UploadsBucket. Coppy và paste đoạn code bên dưới vào file template.yaml trong thư mục sam.\n# DetectLables Lambda Function\rDetectLabelsFunction:\rType: AWS::Serverless::Function\rProperties:\rCodeUri: src/handlers/detectLabels\rEnvironment:\rVariables:\rTASKS_TABLE: !Ref TasksTable\rEvents:\rObjectCreatedEvent:\rType: S3\rProperties:\rBucket: !Ref UploadsBucket\rEvents: s3:ObjectCreated:*\rHandler: app.handler\rPolicies:\r- DynamoDBCrudPolicy:\rTableName: !Ref TasksTable\r- RekognitionDetectOnlyPolicy: {}\r- Version: 2012-10-17\rStatement:\r- Effect: Allow\rAction: s3:GetObject*\rResource: !Sub \u0026#34;arn:aws:s3:::uploads-${AWS::StackName}-${AWS::Region}-${AWS::AccountId}*\u0026#34;\rRuntime: nodejs14.x Chúng sẽ làm như hình dưới đây:\nChú ý ở thuộc tính ObjectCreatedEvent. Event này sẽ trigger Lambda function khi một object được tải lên bucket.\nDeploy lại ứng dụng sau khi thay đổi Với sự thay đổi code của chúng ta khi chỉnh sửa file template.yml và thêm file detectLabels.js, chúng ta cần build và deploy lại ứng dụng để thực thi các thay đổi. Chúng ta sẽ deploy chạy lệnh sau:\nHãy chắn chắn rằng ở terminal, bạn đang ở thư mục sam, chạy câu lệnh này cd ~/environment/serverless-tasks-webapp/sam\rĐầu tiên chúng ta sẽ build ứng dụng:\nsam build Khi build thành công, chúng ta sẽ thấy như hình: Tiếp đến, chúng ta sẽ deploy ứng dụng:\nsam deploy Sau khi deploy thành công, chúng ta sẽ thấy như hình\nBây giờ, chúng ta đã có thể trải nghiệm Amazon Rekognition ở ứng dụng của chúng ta.\nAmazon Rekognition sẽ phân tích các hình ảnh được lưu trữ ở Amazon S3 bucket. Ứng dụng web của chúng ta cho phép bạn được tải ảnh lên và gán vào task. Chúng ta làm như sau:\nSau khi các bạn tạo một task mới, ở phần My Tasks, các bạn sẽ thấy nó và nút Choose file. Click vào nút đó để chọn một ảnh từ máy tính của bạn có đuôi PNG, JPEG, etc. Click vào nút Upload để tải ảnh lên. Sau khi làm các bước trên, bạn sẽ thấy dòng hiển thị quá trình Detecting Labels.\nSau khi quá trình detect hoàn tất, bạn sẽ thấy các label được detect hiển thị.\nMô tả lại quá trình detect label vừa thực hiện Hình ảnh được tải lên vào S3 bucket S3 bucket được cấu hình cho phép trigger Lambda function DetectLabels khi có object được tạo ra trong bucket. Lambda function DetectLabels được gọi và nó sử dụng Amazon Rekognition để detect label của hình ảnh. Detected lables được lưu vào DynamoDB. Ứng dựng refreshes thông tin chi tiết của task. Để ý rằng cách chúng ta thêm một tính năng mới vào ứng dụng của chúng ta mà không thay đổi quá nhiều. Điều này chứng tỏ sự linh hoạt của serverless architectures - khả năng mở rộng và tính module hóa của nó.\n"
},
{
	"uri": "/vi/8-terminate/",
	"title": "Dọn dẹp tài nguyên",
	"tags": [],
	"description": "",
	"content": "SAM-created Resources Cách đơn giản nhất để xóa resources được tạo ra bởi SAM là sử dụng câu lệnh sam delete. Tuy nhiên, trước khi chạy câu lệnh đó, bạn cần chắn chắn rằng S3 bucket chứa hình ảnh tải lên đã được dọn dẹp sạch.\nBạn hãy sử dụng câu lệnh aws s3 ls để thấy được danh sách cái file trong bucket. Hãy làm như hình.\nBạn sẽ thấy bucket tên uploads-tasks-app-ap-southeast-1-127779471063 trong đó ap-southeast-1 là region của bạn và 127779471063 là ID của AWS account.\nHãy đi đến thư mục /sam bằng câu lệnh cd ~/environment/serverless-tasks-webapp/sam. Bucket của workshop này được kích hoạt versioning nên bạn phải dọn dẹp nó bằng AWS SDK. Tìm đến file emtpy_versioned_bucket.py trong thư mục /sam và modify nó bằng cách chỉnh sửa tên bucket trên sau khi chạy câu lệnh aws s3 ls. Lưu lại file và chạy câu lệnh sau để dọn dẹp bucket:\npython empty_versioned_bucket.py Chúng ta sẽ có kết quả như hình:\nBây giờ chúng ta có thể chạy câu lệnh:\nsam delete Vậy là chúng ta đã xóa thành công các resources được tạo ra bởi SAM.\nAmplify Hosting Di chuyển vào thư mục /webapp, chúng ta có thể xóa Amplify project bằng câu lệnh:\ncd ~/environment/serverless-tasks-webapp/webapp\ramplify delete Sau khi xóa thành công, chúng ta sẽ thấy như hình:\nCác bạn hãy nhớ vào IAM console, chọn user amplify-user được tạo ra ở bước 2.4 - Cài đặt Amplify CLI và xóa nó cùng Access Key được tạo ra vì nó không được tự động xóa khi chạy câu lệnh amplify delete.\nCloudWatch Logs Bạn phải xóa các nhóm log trong CloudWatch Logs và streams được tạo ra khi sử dụng ứng dụng. Hãy vào CloudWatch Logs console, tiếp theo vào Log groups ở thanh điều hướng bên trái, chọn các Log group của workshop này và xóa chúng.\nVậy là chúng ta đã dọn dẹp tất cả tài nguyên trong workshop này.\n"
},
{
	"uri": "/vi/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/vi/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]